// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
)

const completeTask = `-- name: CompleteTask :one
UPDATE tasks SET
    status = 'completed',
    updated_at = CURRENT_TIMESTAMP,
    finished_at = CURRENT_TIMESTAMP
WHERE process_id = ?
RETURNING id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at
`

func (q *Queries) CompleteTask(ctx context.Context, processID interface{}) (Task, error) {
	row := q.db.QueryRowContext(ctx, completeTask, processID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks ("type", "process_id", "status") VALUES (?, ?, "pending") RETURNING id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at
`

type CreateTaskParams struct {
	Type      interface{}
	ProcessID interface{}
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask, arg.Type, arg.ProcessID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const failTask = `-- name: FailTask :one
UPDATE tasks SET
    status = 'failed',
    updated_at = CURRENT_TIMESTAMP,
    finished_at = CURRENT_TIMESTAMP,
    error = ?
WHERE process_id = ?
RETURNING id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at
`

type FailTaskParams struct {
	Error     interface{}
	ProcessID interface{}
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, failTask, arg.Error, arg.ProcessID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getTaskByProcessId = `-- name: GetTaskByProcessId :one
SELECT id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at FROM tasks WHERE process_id = ?
`

func (q *Queries) GetTaskByProcessId(ctx context.Context, processID interface{}) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByProcessId, processID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getTasksByStatus = `-- name: GetTasksByStatus :many
SELECT id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at FROM tasks WHERE status = ? ORDER BY updated_at DESC
`

func (q *Queries) GetTasksByStatus(ctx context.Context, status string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ProcessID,
			&i.LogPath,
			&i.Status,
			&i.Retries,
			&i.MaxRetries,
			&i.WorkerID,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queueTask = `-- name: QueueTask :one
UPDATE tasks SET
    status = 'running',
    log_path = ?,
    worker_id = ?,
    updated_at = CURRENT_TIMESTAMP,
    started_at = CURRENT_TIMESTAMP
WHERE process_id = ?
RETURNING id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at
`

type QueueTaskParams struct {
	LogPath   interface{}
	WorkerID  sql.NullInt64
	ProcessID interface{}
}

func (q *Queries) QueueTask(ctx context.Context, arg QueueTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, queueTask, arg.LogPath, arg.WorkerID, arg.ProcessID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks SET
    status = ?,
    log_path = ?,
    retries = ?,
    max_retries = ?,
    worker_id = ?,
    process_id = ?,
    error = ?,
    updated_at = CURRENT_TIMESTAMP,
    started_at = ?,
    finished_at = ?
WHERE id = ?
RETURNING id, type, process_id, log_path, status, retries, max_retries, worker_id, error, created_at, updated_at, started_at, finished_at
`

type UpdateTaskParams struct {
	Status     string
	LogPath    interface{}
	Retries    int64
	MaxRetries int64
	WorkerID   sql.NullInt64
	ProcessID  interface{}
	Error      interface{}
	StartedAt  sql.NullTime
	FinishedAt sql.NullTime
	ID         interface{}
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Status,
		arg.LogPath,
		arg.Retries,
		arg.MaxRetries,
		arg.WorkerID,
		arg.ProcessID,
		arg.Error,
		arg.StartedAt,
		arg.FinishedAt,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.ProcessID,
		&i.LogPath,
		&i.Status,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}
